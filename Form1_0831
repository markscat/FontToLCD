
using System.Text;
using System.Windows.Forms;
using System;
using System.Drawing;
//using System.Text;
using System.Windows.Forms;

namespace FontToLCD
    {
        public partial class FontToLCD : Form
        {
            public FontToLCD()
            {
                InitializeComponent();
                InitForm();
            }

            private void InitForm()
            {
                // 初始化字型 ComboBox
                foreach (FontFamily ff in FontFamily.Families)
                FontType.Items.Add(ff.Name);
                FontType.SelectedIndex = 0;

                // 初始化大小 ComboBox
            //    LedFont.Items.AddRange(new object[] { "8", "16", "32" });
            //    LedFont.SelectedIndex = 0; // 預設 8
                FontSize.Items.AddRange(new object[] { "8", "12", "16", "24", "32" });
                FontSize.SelectedIndex = 0;
            // 按鈕事件
                button1.Click += Button1_Click;

            // 預設文字
                Imput.Text = "a";
            }

        private void Button1_Click(object? sender, EventArgs e)
        {
            if (string.IsNullOrWhiteSpace(Imput.Text)) return;

            string text = Imput.Text;
            string fontName = FontType.SelectedItem?.ToString() ?? "Arial";
            int fontSize = int.TryParse(FontSize.SelectedItem?.ToString(), out int fs) ? fs : 16;

            // 這裡先用輸出的大小決定矩陣大小 (例: 8 → 8x16, 16 → 16x16, 32 → 32x32)
            int bmpWidth = fontSize;

            int bmpHeight = (fontSize <= 8) ? fontSize : fontSize * 2; // 小字用 1:1，大字用 1:2 比例

            // 畫字
            using (Bitmap bmp = DrawCharToBitmap(text, fontName, fontSize, bmpWidth, bmpHeight))          
            
            {
                // 轉矩陣
                int[,] matrix = BitmapToMatrix(bmp);

                // 預覽（放大顯示）
                BitView.Image = DrawMatrixPreview(matrix, 20);

                // 轉 HEX
                Hex.Text = MatrixToHexString(matrix);
            }
        }

        private Bitmap DrawCharToBitmap(string text, string fontName, float fontSize, int targetWidth, int targetHeight)
        {
            // 步驟 1: 在一個臨時的大畫布上繪製字元
            // 這個畫布的大小要足夠大，以確保任何大小的字體都能完整繪製，且有足夠的解析度。
            int tempCanvasSize = 256;
            using (Bitmap tempBmp = new Bitmap(tempCanvasSize, tempCanvasSize))
            {
                using (Graphics g = Graphics.FromImage(tempBmp))
                {
                    g.Clear(Color.White);
                    g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;

                    // 使用一個相對較大的字體進行繪製
                    using (Font font = new Font(fontName, tempCanvasSize / 2f, FontStyle.Regular, GraphicsUnit.Pixel))
                    {
                        StringFormat sf = new StringFormat
                        {
                            Alignment = StringAlignment.Center,
                            LineAlignment = StringAlignment.Center
                        };
                        g.DrawString(text, font, Brushes.Black, new RectangleF(0, 0, tempCanvasSize, tempCanvasSize), sf);
                    }
                }

                // 步驟 2: 掃描畫布，找出字元筆劃的實際視覺邊界
                RectangleF bounds = FindVisualBoundingBox(tempBmp);

                // 如果找不到任何筆劃 (例如輸入是空白字元)，就返回一個全白的目標大小圖片
                if (bounds.IsEmpty || bounds.Width <= 0 || bounds.Height <= 0)
                {
                    Bitmap emptyBmp = new Bitmap(targetWidth, targetHeight);
                    using (Graphics g = Graphics.FromImage(emptyBmp))
                    {
                        g.Clear(Color.White);
                    }
                    return emptyBmp;
                }

                // 步驟 3: 根據邊界裁剪出最緊湊的字元，並縮放到目標大小
                Bitmap finalBmp = new Bitmap(targetWidth, targetHeight);
                using (Graphics g = Graphics.FromImage(finalBmp))
                {
                    g.Clear(Color.White);
                    g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;

                    // 將 tempBmp 中 bounds 區域的圖像，繪製(並縮放)到 finalBmp 的整個畫布上
                    g.DrawImage(tempBmp,
                                new Rectangle(0, 0, targetWidth, targetHeight), // 目標矩形 (填滿)
                                bounds, // 來源矩形 (從大圖中裁剪的區域)
                                GraphicsUnit.Pixel);
                }

                return finalBmp;
            }
        }

        /// <summary>
        /// 掃描 Bitmap，找出非白色像素構成的最小邊界矩形。
        /// </summary>
        /// <param name="bmp">要掃描的 Bitmap</param>
        /// <returns>包含實際內容的矩形區域</returns>
        private RectangleF FindVisualBoundingBox(Bitmap bmp)
        {
            int top = -1, bottom = -1, left = -1, right = -1;

            // 從上到下掃描，找第一個有內容的 y 座標 (top)
            for (int y = 0; y < bmp.Height; y++)
            {
                for (int x = 0; x < bmp.Width; x++)
                {
                    if (bmp.GetPixel(x, y).R < 250) // 容忍一點點反鋸齒的灰階
                    {
                        top = y;
                        goto FoundTop;
                    }
                }
            }
        FoundTop:
            if (top == -1) return RectangleF.Empty; // 全白圖片

            // 從下到上掃描，找第一個有內容的 y 座標 (bottom)
            for (int y = bmp.Height - 1; y >= 0; y--)
            {
                for (int x = 0; x < bmp.Width; x++)
                {
                    if (bmp.GetPixel(x, y).R < 250)
                    {
                        bottom = y;
                        goto FoundBottom;
                    }
                }
            }
        FoundBottom:

            // 從左到右掃描，找第一個有內容的 x 座標 (left)
            for (int x = 0; x < bmp.Width; x++)
            {
                for (int y = top; y <= bottom; y++)
                {
                    if (bmp.GetPixel(x, y).R < 250)
                    {
                        left = x;
                        goto FoundLeft;
                    }
                }
            }
        FoundLeft:

            // 從右到左掃描，找第一個有內容的 x 座標 (right)
            for (int x = bmp.Width - 1; x >= 0; x--)
            {
                for (int y = top; y <= bottom; y++)
                {
                    if (bmp.GetPixel(x, y).R < 250)
                    {
                        right = x;
                        goto FoundRight;
                    }
                }
            }
        FoundRight:

            // 加上一點 padding 避免筆劃被切到
            int padding = 2;
            left = Math.Max(0, left - padding);
            right = Math.Min(bmp.Width - 1, right + padding);
            top = Math.Max(0, top - padding);
            bottom = Math.Min(bmp.Height - 1, bottom + padding);

            return new RectangleF(left, top, right - left + 1, bottom - top + 1);
        }

        //#define code0829


#if code0829
        private Bitmap DrawCharToBitmap(string text, string fontName, float fontSize, int targetWidth, int targetHeight)
        {
            // 為了更精準地反鋸齒，我們在高解析度的畫布上繪製再縮小
            int scale = 8; // 放大倍數，可以根據需要調整
            int bigWidth = targetWidth * scale;
            int bigHeight = targetHeight * scale;

            Bitmap bigBmp = new Bitmap(bigWidth, bigHeight);

            using (Graphics g = Graphics.FromImage(bigBmp))
            {
                g.Clear(Color.White);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;

                // 建立一個初始大小的字體用於測量
                // 注意：字體大小的單位和計算方式是關鍵
                using (Font font = new Font(fontName, bigHeight, GraphicsUnit.Pixel))
                {
                    // 測量字元在給定字體下的大小
                    SizeF charSize = g.MeasureString(text, font);

                    // 根據測量結果，重新計算一個合適的字體大小，讓字元能“填滿”畫布
                    // 這裡我們以高度為基準進行縮放
                    float scalingFactor = Math.Min(bigWidth / charSize.Width, bigHeight / charSize.Height);
                    float finalFontSize = bigHeight * scalingFactor * 0.9f; // 乘上一個係數(例如0.9)來保留一些邊界

                    using (Font finalFont = new Font(fontName, finalFontSize, FontStyle.Regular, GraphicsUnit.Pixel))
                    {
                        // 使用最終計算出的字體大小再次測量，以取得更精確的位置
                        SizeF finalCharSize = g.MeasureString(text, finalFont);

                        // 計算繪製的起始位置 (x, y)，使其在畫布中置中
                        float x = (bigWidth - finalCharSize.Width) / 2.0f;
                        float y = (bigHeight - finalCharSize.Height) / 2.0f;

                        // 繪製字元
                        g.DrawString(text, finalFont, Brushes.Black, x, y);
                    }
                }
            }

            // 將高解析度的 Bitmap 縮小到目標尺寸
            Bitmap smallBmp = new Bitmap(targetWidth, targetHeight);
            using (Graphics g = Graphics.FromImage(smallBmp))
            {
                // 使用高品質的縮放演算法
                g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                g.DrawImage(bigBmp, 0, 0, targetWidth, targetHeight);
            }

            bigBmp.Dispose();
            return smallBmp;
        }


        private Bitmap DrawCharToBitmap(string text, string fontName, float fontSize, int targetWidth, int targetHeight)
        {
            int scale = 8; // 放大倍數，可調整
            int bigWidth = targetWidth * scale;
            int bigHeight = targetHeight * scale;


            // 1. 大尺寸畫字
            Bitmap bigBmp = new Bitmap(bigWidth, bigHeight);

            using (Graphics g = Graphics.FromImage(bigBmp))
            {
                g.Clear(Color.White);             
                //g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;

                using (Font font = new Font(fontName, bigHeight * 0.8f, FontStyle.Regular, GraphicsUnit.Pixel))

                //using (Font font = new Font(fontName, fontSize, FontStyle.Regular, GraphicsUnit.Pixel))
                {

                    StringFormat sf = new StringFormat();
                    sf.Alignment = StringAlignment.Center;
                    sf.LineAlignment = StringAlignment.Center;

                    g.DrawString(text, font, Brushes.Black, new RectangleF(0, 0, bigWidth, bigHeight), sf);
                }
            }

            // 2. 縮小到目標矩陣大小
            Bitmap smallBmp = new Bitmap(targetWidth, targetHeight);
            using (Graphics g = Graphics.FromImage(smallBmp))
            {
                g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                g.DrawImage(bigBmp, new Rectangle(0, 0, targetWidth, targetHeight),
                            new Rectangle(0, 0, bigWidth, bigHeight),
                            GraphicsUnit.Pixel);
            }

            bigBmp.Dispose();
            return smallBmp;
        }
#endif

        // Bitmap 轉矩陣，灰階判斷
        private int[,] BitmapToMatrix(Bitmap bmp)
        {
            int[,] matrix = new int[bmp.Height, bmp.Width];
            for (int y = 0; y < bmp.Height; y++)
            {
                for (int x = 0; x < bmp.Width; x++)
                {
                    Color p = bmp.GetPixel(x, y);
                    int gray = (int)(0.3 * p.R + 0.59 * p.G + 0.11 * p.B);
                    matrix[y, x] = gray < 128 ? 1 : 0; // 黑色=1
                }
            }
            return matrix;
        }

        private Bitmap DrawMatrixPreview(int[,] matrix, int scale = 20)
        {
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);
            Bitmap bmp = new Bitmap(cols * scale, rows * scale);

            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.Clear(Color.White);

                for (int y = 0; y < rows; y++)
                {
                    for (int x = 0; x < cols; x++)
                    {
                        Rectangle rect = new Rectangle(x * scale, y * scale, scale, scale);
                        if (matrix[y, x] == 1)
                        {
                            g.FillRectangle(Brushes.Black, rect);
                        }
                        g.DrawRectangle(Pens.Gray, rect); // 畫格子線
                    }
                }
            }
            return bmp;
        }
        
        private string MatrixToHexString(int[,] matrix)
        {
            StringBuilder sb = new StringBuilder();
            int rows = matrix.GetLength(0);
            int cols = matrix.GetLength(1);

            sb.AppendLine("{");
            for (int y = 0; y < rows; y++)
            {
                sb.Append("  ");
                int value = 0;
                int bitCount = 0;

                for (int x = 0; x < cols; x++)
                {
                    value = (value << 1) | matrix[y, x];
                    bitCount++;

                    if (bitCount == 8)
                    {
                        sb.Append($"0x{value:X2}, ");
                        value = 0;
                        bitCount = 0;
                    }
                }

                // 如果寬度不是8的倍數，補齊最後一個 byte
                if (bitCount > 0)
                {
                    value <<= (8 - bitCount);
                    sb.Append($"0x{value:X2}, ");
                }

                sb.AppendLine();
            }
            sb.AppendLine("};");
            return sb.ToString();
        }


        /*
            private void Button1_Click(object? sender, EventArgs e){
            if (string.IsNullOrEmpty(Imput.Text)) return;
            if (FontType.SelectedItem == null || FontSize.SelectedItem == null) return;
            
            string text = Imput.Text;
            string fontName = FontType.SelectedItem.ToString() ?? "Arial";
            int selectedPt = int.Parse(FontSize.SelectedItem.ToString() ?? "8");
            int fontSize = int.TryParse(FontSize.SelectedItem?.ToString(), out int fs) ? fs : 16;


            // 自動決定矩陣尺寸
            int matrixWidth = fontSize;
            int matrixHeight= fontSize * 2;

            using (Bitmap bmp = new Bitmap(matrixWidth, matrixHeight))
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.Clear(Color.White);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;

                // 文字居中顯示
                StringFormat sf = new StringFormat();
                sf.Alignment = StringAlignment.Center;
                sf.LineAlignment = StringAlignment.Center;


            }




                if (selectedPt <= 6)        { matrixWidth = 6; matrixHeight = 12; }
                else if (selectedPt <= 8)   { matrixWidth = 8; matrixHeight = 16; }
                else if (selectedPt <= 12)  { matrixWidth = 12; matrixHeight = 16; }
                else                        { matrixWidth = 16; matrixHeight = 16; }


            // 計算字型大小
                fontSize = matrixHeight * 0.8f; // 留點邊距
                Bitmap bmp = DrawCharToBitmap(text, fontName, fontSize, matrixWidth, matrixHeight);


                // 轉矩陣
                int[,] matrix = BitmapToMatrix(bmp);

                // 顯示預覽
                BitView.Image = DrawMatrixPreview(matrix, 20);

                // 顯示 HEX
                Hex.Text = MatrixToHexString(matrix);
        }
        */


        /*
            private Bitmap DrawCharToBitmap(string text, string fontName, int size)
            {
                Bitmap bmp = new Bitmap(size, size);
                using (Graphics g = Graphics.FromImage(bmp))
                {
                    g.Clear(Color.White);
                    using (Font font = new Font(fontName, size))
                    {
                        g.DrawString(text, font, Brushes.Black, -1, -2); // 微調位置
                    }
                }
                return bmp;
            }*/

        /*
            private string MatrixToString(int[,] matrix)
            {
                StringBuilder sb = new StringBuilder();
                int rows = matrix.GetLength(0);
                int cols = matrix.GetLength(1);
                sb.AppendLine("{");
                for (int y = 0; y < rows; y++)
                {
                    sb.Append("  { ");
                    for (int x = 0; x < cols; x++)
                    {
                        sb.Append(matrix[y, x]);
                        if (x != cols - 1) sb.Append(", ");
                    }
                    sb.AppendLine(" },");
                }
                sb.AppendLine("};");
                return sb.ToString();
            }
        */


        /*
        private Bitmap DrawCharToBitmap(string text, string fontName, int size)
        {
            // 1. 先用大尺寸畫布把字完整畫出來
            int bigSize = 32; // 放大畫布
            Bitmap bigBmp = new Bitmap(bigSize, bigSize);

            using (Graphics g = Graphics.FromImage(bigBmp))
            {
                g.Clear(Color.White);
                g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.SingleBitPerPixelGridFit;

                using (Font font = new Font(fontName, bigSize * 3 / 4, GraphicsUnit.Pixel))
                {
                    StringFormat format = new StringFormat();
                    format.Alignment = StringAlignment.Center;
                    format.LineAlignment = StringAlignment.Center;

                    g.DrawString(text, font, Brushes.Black, new Rectangle(0, 0, bigSize, bigSize), format);
                }
            }

            // 2. 縮小到目標尺寸（size × size）
            Bitmap bmp = new Bitmap(size, size);
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                g.DrawImage(bigBmp, new Rectangle(0, 0, size, size));
            }

            return bmp;
        }
        */



        /*
        private Bitmap DrawCharToBitmap(string text, string fontName, int size)
        {
            // 先用比較大的畫布來畫字，避免被切掉
            int bigSize = size * 4; // 放大 4 倍畫，再縮小
            Bitmap bigBmp = new Bitmap(bigSize, bigSize);

            using (Graphics g = Graphics.FromImage(bigBmp))
            {
                g.Clear(Color.White);

                using (Font font = new Font(fontName, bigSize * 3 / 4, GraphicsUnit.Pixel))
                {
                    StringFormat format = new StringFormat();
                    format.Alignment = StringAlignment.Center;
                    format.LineAlignment = StringAlignment.Center;

                    Rectangle rect = new Rectangle(0, 0, bigSize, bigSize);
                    g.DrawString(text, font, Brushes.Black, rect, format);
                }
            }

            // 再縮小到 size × size
            Bitmap bmp = new Bitmap(size, size);
            using (Graphics g = Graphics.FromImage(bmp))
            {
                g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic;
                g.DrawImage(bigBmp, new Rectangle(0, 0, size, size));
            }

            return bmp;
        }

        */
    }
}
